const assert = require('assert');
const vscode = require('vscode');
const path = require('path');
const fs = require('fs');

// Import extension modules for testing
const { generateFileAliases } = require('../src/updateLuaFileAliases');

// Import shared test utilities
const {
    mockWorkspaceConfig,
    createTestFiles,
    cleanupTestFiles,
    setupTestWorkspace
} = require('./testUtils');

suite('File Alias Generation Tests', () => {
    vscode.window.showInformationMessage('Starting File Alias Generation tests...');

    let testWorkspaceUri;
    let testWorkspacePath;

    suiteSetup(async () => {
        testWorkspaceUri = vscode.Uri.file(path.join(__dirname, 'alias-test-workspace'));
        testWorkspacePath = testWorkspaceUri.fsPath;
        
        if (!fs.existsSync(testWorkspacePath)) {
            fs.mkdirSync(testWorkspacePath, { recursive: true });
        }
        
        await setupTestWorkspace(testWorkspacePath);
    });

    suiteTeardown(async () => {
        if (fs.existsSync(testWorkspacePath)) {
            fs.rmSync(testWorkspacePath, { recursive: true, force: true });
        }
    });

    test('Should generate unique aliases for non-conflicting files', async () => {
        const restore = mockWorkspaceConfig(testWorkspaceUri);

        try {
            generateFileAliases();
            
            const luaurcPath = path.join(testWorkspacePath, '.luaurc');
            assert.ok(fs.existsSync(luaurcPath), '.luaurc should exist');
            
            const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
            assert.ok(luaurcContent.aliases, 'Aliases should be generated');
            assert.ok(luaurcContent.aliases.ServerMain, 'ServerMain alias should exist');
            assert.ok(luaurcContent.aliases.ClientMain, 'ClientMain alias should exist');
            assert.ok(luaurcContent.aliases.Config, 'Config alias should exist');
            assert.ok(luaurcContent.aliases.Utils, 'Utils alias should exist for init file');
            assert.ok(!luaurcContent.aliases.PrivateFile, 'Private files should be ignored');
        } finally {
            restore();
        }
    });

    test('Should handle ambiguous aliases correctly', async () => {
        const duplicateFile = path.join(testWorkspacePath, 'src/Client/Config.luau');
        fs.writeFileSync(duplicateFile, 'local ClientConfig = {}\nreturn ClientConfig');

        const restore = mockWorkspaceConfig(testWorkspaceUri, {
            directoriesToScan: ['src/Server', 'src/Client', 'src/Shared']
        });

        try {
            generateFileAliases();
            
            const luaurcPath = path.join(testWorkspacePath, '.luaurc');
            const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
            
            const autoGeneratedKeys = Object.keys(luaurcContent.aliases).filter(key => 
                !['@Server', '@Client', '@Shared'].includes(key)
            );
            assert.ok(!autoGeneratedKeys.includes('Config'), 'Ambiguous aliases should not be auto-generated');
        } finally {
            restore();
            fs.unlinkSync(duplicateFile);
        }
    });

    test('Should handle files with same basename in different subdirectories', async () => {
        const testDirs = ['src/Server/Combat', 'src/Client/Combat'];
        for (const dir of testDirs) {
            const fullPath = path.join(testWorkspacePath, dir);
            if (!fs.existsSync(fullPath)) {
                fs.mkdirSync(fullPath, { recursive: true });
            }
        }

        const conflictFiles = {
            'src/Server/Combat/Weapon.luau': 'local ServerWeapon = {}\nreturn ServerWeapon',
            'src/Client/Combat/Weapon.luau': 'local ClientWeapon = {}\nreturn ClientWeapon'
        };

        for (const [filePath, content] of Object.entries(conflictFiles)) {
            const fullPath = path.join(testWorkspacePath, filePath);
            fs.writeFileSync(fullPath, content, 'utf8');
        }

        const restore = mockWorkspaceConfig(testWorkspaceUri, {
            directoriesToScan: ['src/Server', 'src/Client']
        });

        try {
            generateFileAliases();
            
            const luaurcPath = path.join(testWorkspacePath, '.luaurc');
            const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
            
            assert.ok(!luaurcContent.aliases.Weapon, 'Ambiguous files should not generate aliases');
        } finally {
            restore();
            for (const filePath of Object.keys(conflictFiles)) {
                const fullPath = path.join(testWorkspacePath, filePath);
                if (fs.existsSync(fullPath)) fs.unlinkSync(fullPath);
            }
        }
    });

    test('Should recognize files and folders with init.luau files that share the same name constitute an ambiguous alias', async () => {
        const testDir = path.join(testWorkspacePath, 'src/Shared/TestModule');
        const standaloneFile = path.join(testWorkspacePath, 'src/Shared/TestModule.luau');
        const initFile = path.join(testDir, 'init.luau');

        const restore = mockWorkspaceConfig(testWorkspaceUri, {
            directoriesToScan: ['src/Shared']
        });

        try {
            // Step 1: Create standalone file only
            fs.writeFileSync(standaloneFile, 'return { standalone = true }');
            generateFileAliases();
            
            let luaurcPath = path.join(testWorkspacePath, '.luaurc');
            let luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
            
            assert.ok(luaurcContent.aliases.TestModule, 'Step 1: Should create alias when only standalone file exists');
            assert.ok(luaurcContent.aliases.TestModule.includes('TestModule.luau'), 'Step 1: Should point to standalone file');

            // Step 2: Add init file (creates ambiguity)
            fs.mkdirSync(testDir, { recursive: true });
            fs.writeFileSync(initFile, 'return { main = true }');
            generateFileAliases();
            
            luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
            
            assert.ok(!luaurcContent.aliases.TestModule, 'Step 2: Should NOT create alias when both init file and standalone file exist (ambiguous)');

            // Step 3: Remove init file (removes ambiguity, standalone file should get alias again)
            fs.rmSync(testDir, { recursive: true, force: true });
            generateFileAliases();
            
            luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
            
            assert.ok(luaurcContent.aliases.TestModule, 'Step 3: Should restore alias when init file removed and only standalone remains');
            assert.ok(luaurcContent.aliases.TestModule.includes('TestModule.luau'), 'Step 3: Should point to standalone file again');

        } finally {
            restore();
            if (fs.existsSync(testDir)) {
                fs.rmSync(testDir, { recursive: true, force: true });
            }
            if (fs.existsSync(standaloneFile)) {
                fs.unlinkSync(standaloneFile);
            }
        }
    });

    test('Should handle files with special characters', () => {
        const specialFiles = {
            'src/Server/File-With-Dashes.luau': 'return {}',
            'src/Server/File_With_Underscores.luau': 'return {}',
            'src/Server/FileWithNumbers123.luau': 'return {}'
        };

        for (const [filePath, content] of Object.entries(specialFiles)) {
            const fullPath = path.join(testWorkspacePath, filePath);
            fs.writeFileSync(fullPath, content, 'utf8');
        }

        const restore = mockWorkspaceConfig(testWorkspaceUri, {
            directoriesToScan: ['src/Server']
        });

        try {
            generateFileAliases();
            
            const luaurcPath = path.join(testWorkspacePath, '.luaurc');
            const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
            
            assert.ok(luaurcContent.aliases['File-With-Dashes'], 'Should handle dashes in filenames');
            assert.ok(luaurcContent.aliases['File_With_Underscores'], 'Should handle underscores in filenames');
            assert.ok(luaurcContent.aliases['FileWithNumbers123'], 'Should handle numbers in filenames');
        } finally {
            restore();
            for (const filePath of Object.keys(specialFiles)) {
                const fullPath = path.join(testWorkspacePath, filePath);
                if (fs.existsSync(fullPath)) fs.unlinkSync(fullPath);
            }
        }
    });

    test('Should ignore .server and .client files', () => {
        const serverClientFiles = {
            'src/Server/ServerScript.server.luau': 'print("server")',
            'src/Client/ClientScript.client.luau': 'print("client")',
            'src/Shared/RegularScript.luau': 'print("regular")'
        };

        for (const [filePath, content] of Object.entries(serverClientFiles)) {
            const fullPath = path.join(testWorkspacePath, filePath);
            fs.writeFileSync(fullPath, content, 'utf8');
        }

        const restore = mockWorkspaceConfig(testWorkspaceUri, {
            directoriesToScan: ['src/Server', 'src/Client', 'src/Shared']
        });

        try {
            generateFileAliases();
            
            const luaurcPath = path.join(testWorkspacePath, '.luaurc');
            const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
            
            assert.ok(!luaurcContent.aliases.ServerScript, 'Should ignore .server files');
            assert.ok(!luaurcContent.aliases.ClientScript, 'Should ignore .client files');
            assert.ok(luaurcContent.aliases.RegularScript, 'Should include regular files');
        } finally {
            restore();
            for (const filePath of Object.keys(serverClientFiles)) {
                const fullPath = path.join(testWorkspacePath, filePath);
                if (fs.existsSync(fullPath)) fs.unlinkSync(fullPath);
            }
        }
    });
});
