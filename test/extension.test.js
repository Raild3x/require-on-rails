const assert = require('assert');
const vscode = require('vscode');
const path = require('path');
const fs = require('fs');

// Import extension modules for testing
const { generateFileAliases } = require('../src/updateLuaFileAliases');
const { updateRequireNames } = require('../src/updateRequireNames');
const { hideLines, unhideLines } = require('../src/hideLines');

suite('RequireOnRails Extension Test Suite', () => {
    vscode.window.showInformationMessage('Starting RequireOnRails tests...');

    let testWorkspaceUri;
    let testWorkspacePath;

    suiteSetup(async () => {
        // Create a test workspace
        testWorkspaceUri = vscode.Uri.file(path.join(__dirname, 'test-workspace'));
        testWorkspacePath = testWorkspaceUri.fsPath;
        
        // Ensure test workspace exists
        if (!fs.existsSync(testWorkspacePath)) {
            fs.mkdirSync(testWorkspacePath, { recursive: true });
        }
        
        // Create test directory structure
        await setupTestWorkspace();
    });

    suiteTeardown(async () => {
        // Clean up test workspace
        if (fs.existsSync(testWorkspacePath)) {
            fs.rmSync(testWorkspacePath, { recursive: true, force: true });
        }
    });

    async function setupTestWorkspace() {
        const dirs = [
            'src/Server',
            'src/Client', 
            'src/Shared',
            'src/Server/Systems',
            'src/Shared/Utils',
            'Packages',
            '_Private'
        ];

        // Create directories
        for (const dir of dirs) {
            const fullPath = path.join(testWorkspacePath, dir);
            if (!fs.existsSync(fullPath)) {
                fs.mkdirSync(fullPath, { recursive: true });
            }
        }

        // Create test files
        const testFiles = {
            'src/Server/ServerMain.luau': 'print("Server main")',
            'src/Server/Systems/PlayerManager.luau': 'local PlayerManager = {}\nreturn PlayerManager',
            'src/Client/ClientMain.luau': 'print("Client main")',
            'src/Shared/Config.luau': 'local Config = {}\nreturn Config',
            'src/Shared/Utils/StringUtils.luau': 'local StringUtils = {}\nreturn StringUtils',
            'src/Shared/Utils/init.luau': 'return { StringUtils = require("StringUtils") }',
            'Packages/TestPackage.luau': 'return {}',
            '_Private/PrivateFile.luau': 'return {}'
        };

        for (const [filePath, content] of Object.entries(testFiles)) {
            const fullPath = path.join(testWorkspacePath, filePath);
            fs.writeFileSync(fullPath, content, 'utf8');
        }

        // Create configuration files
        const luaurcConfig = {
            aliases: {},
            languageMode: "strict"
        };
        fs.writeFileSync(path.join(testWorkspacePath, '.luaurc'), JSON.stringify(luaurcConfig, null, 4));

        const requireOnRailsConfig = {
            manualAliases: {
                "@Server": "src/Server",
                "@Client": "src/Client", 
                "@Shared": "src/Shared"
            },
            autoGeneratedAliases: {}
        };
        fs.writeFileSync(path.join(testWorkspacePath, '.requireonrails.json'), JSON.stringify(requireOnRailsConfig, null, 4));
    }

    suite('File Alias Generation Tests', () => {
        test('Should generate unique aliases for non-conflicting files', async () => {
            // Mock workspace configuration with complete interface
            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'directoriesToScan':
                            return ['src/Server', 'src/Client', 'src/Shared', 'Packages'];
                        case 'ignoreDirectories':
                            return ['^_.*'];
                        case 'supportedExtensions':
                            return ['.lua', '.luau'];
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            // Mock workspace folders properly by stubbing the property
            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                generateFileAliases();
                
                // Check if .luaurc was updated
                const luaurcPath = path.join(testWorkspacePath, '.luaurc');
                assert.ok(fs.existsSync(luaurcPath), '.luaurc should exist');
                
                const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
                assert.ok(luaurcContent.aliases, 'Aliases should be generated');
                
                // Check for expected aliases
                assert.ok(luaurcContent.aliases.ServerMain, 'ServerMain alias should exist');
                assert.ok(luaurcContent.aliases.ClientMain, 'ClientMain alias should exist');
                assert.ok(luaurcContent.aliases.Config, 'Config alias should exist');
                assert.ok(luaurcContent.aliases.Utils, 'Utils alias should exist for init file');
                
                // Check that private files are ignored
                assert.ok(!luaurcContent.aliases.PrivateFile, 'Private files should be ignored');
            } finally {
                // Restore original configuration
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
            }
        });

        test('Should handle ambiguous aliases correctly', async () => {
            // Create duplicate file names in different directories
            const duplicateFile = path.join(testWorkspacePath, 'src/Client/Config.luau');
            fs.writeFileSync(duplicateFile, 'local ClientConfig = {}\nreturn ClientConfig');

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'directoriesToScan':
                            return ['src/Server', 'src/Client', 'src/Shared'];
                        case 'ignoreDirectories':
                            return ['^_.*'];
                        case 'supportedExtensions':
                            return ['.lua', '.luau'];
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                generateFileAliases();
                
                const luaurcPath = path.join(testWorkspacePath, '.luaurc');
                const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
                
                // Config should not be auto-generated due to ambiguity
                // Only manual aliases should contain it
                const autoGeneratedKeys = Object.keys(luaurcContent.aliases).filter(key => 
                    !['@Server', '@Client', '@Shared'].includes(key)
                );
                assert.ok(!autoGeneratedKeys.includes('Config'), 'Ambiguous aliases should not be auto-generated');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                fs.unlinkSync(duplicateFile);
            }
        });
    });

    suite('Require Statement Update Tests', () => {
        test('Should detect file rename operation', () => {
            const oldPath = path.join(testWorkspacePath, 'src/Server/OldName.luau');
            const newPath = path.join(testWorkspacePath, 'src/Server/NewName.luau');
            
            // Create a test file
            fs.writeFileSync(oldPath, 'return {}');
            
            // Mock the updateRequireNames function to test operation detection
            const originalShowInformationMessage = vscode.window.showInformationMessage;
            let capturedMessage = '';
            vscode.window.showInformationMessage = (message) => {
                capturedMessage = message;
                return Promise.resolve('No');
            };

            // Add proper configuration mocking
            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'enableAbsolutePathUpdates':
                            return true;
                        case 'enableCollisionDetection':
                            return true;
                        case 'enableBasenameUpdates':
                            return true;
                        case 'directoriesToScan':
                            return ['src/Server', 'src/Client', 'src/Shared'];
                        case 'ignoreDirectories':
                            return ['^_.*'];
                        case 'supportedExtensions':
                            return ['.lua', '.luau'];
                        case 'requirePrefix':
                            return '@';
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                // Simulate rename
                fs.renameSync(oldPath, newPath);
                updateRequireNames(newPath, oldPath);
                
                assert.ok(capturedMessage.includes('renamed'), 'Should detect rename operation');
                assert.ok(capturedMessage.includes('OldName'), 'Should include old filename');
                assert.ok(capturedMessage.includes('NewName'), 'Should include new filename');
            } finally {
                vscode.window.showInformationMessage = originalShowInformationMessage;
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                if (fs.existsSync(newPath)) fs.unlinkSync(newPath);
                if (fs.existsSync(oldPath)) fs.unlinkSync(oldPath);
            }
        });

        test('Should detect file move operation', () => {
            const oldPath = path.join(testWorkspacePath, 'src/Server/TestFile.luau');
            const newPath = path.join(testWorkspacePath, 'src/Shared/TestFile.luau');
            
            fs.writeFileSync(oldPath, 'return {}');
            
            // Mock the updateRequireNames function to test operation detection
            const originalShowInformationMessage = vscode.window.showInformationMessage;
            let capturedMessage = '';
            let messageCount = 0;
            vscode.window.showInformationMessage = (message, ...options) => {
                console.log(`Message ${++messageCount}: ${message}`);
                capturedMessage = message;
                return Promise.resolve('No');
            };

            // Add proper configuration mocking
            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'enableAbsolutePathUpdates':
                            return true;
                        case 'enableCollisionDetection':
                            return true;
                        case 'enableBasenameUpdates':
                            return true;
                        case 'directoriesToScan':
                            return ['src/Server', 'src/Client', 'src/Shared'];
                        case 'ignoreDirectories':
                            return ['^_.*'];
                        case 'supportedExtensions':
                            return ['.lua', '.luau'];
                        case 'requirePrefix':
                            return '@';
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                fs.renameSync(oldPath, newPath);
                updateRequireNames(newPath, oldPath);
                
                // The actual behavior: when basename doesn't change, it logs but doesn't prompt for basename updates
                // Instead, it goes directly to absolute path updates
                
                // Should show absolute path update prompt since the file moved between @Server and @Shared
                assert.ok(capturedMessage.includes('absolute require paths'), 'Should prompt for absolute path updates');
                assert.ok(capturedMessage.includes('@Server/TestFile'), 'Should include old absolute path');
                assert.ok(capturedMessage.includes('@Shared/TestFile'), 'Should include new absolute path');
            } finally {
                vscode.window.showInformationMessage = originalShowInformationMessage;
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                if (fs.existsSync(newPath)) fs.unlinkSync(newPath);
                if (fs.existsSync(oldPath)) fs.unlinkSync(oldPath);
            }
        });

        test('Should verify move operation is detected correctly', () => {
            // Test just the analysis function directly to verify it works
            const { analyzeFileOperation } = require('../src/updateRequireNames');
            
            const oldPath = path.join(testWorkspacePath, 'src/Server/TestFile.luau');
            const newPath = path.join(testWorkspacePath, 'src/Shared/TestFile.luau');
            
            const operationInfo = analyzeFileOperation(newPath, oldPath);
            
            assert.ok(operationInfo !== null, 'Should detect an operation');
            assert.strictEqual(operationInfo.operationType, 'moved', 'Should detect move operation');
            assert.strictEqual(operationInfo.isMove, true, 'isMove should be true');
            assert.strictEqual(operationInfo.isRename, false, 'isRename should be false');
            assert.strictEqual(operationInfo.oldFileBasename, 'TestFile', 'Old basename should be correct');
            assert.strictEqual(operationInfo.newFileBasename, 'TestFile', 'New basename should be correct');
        });
    });

    suite('Line Hiding Tests', () => {
        test('Should prompt to add missing import require definition', async () => {
            const testContent = `
local MyModule = require("@MyModule")
return MyModule
            `.trim();

            const originalShowWarningMessage = vscode.window.showWarningMessage;
            let promptShown = false;
            let capturedWarningMessage = '';
            vscode.window.showWarningMessage = (message) => {
                console.log(`Warning message shown: "${message}"`);
                capturedWarningMessage = message;
                if (message.includes('missing the import require definition')) {
                    promptShown = true;
                }
                return Promise.resolve('No');
            };

            const originalConfig = vscode.workspace.getConfiguration;
            let configRequests = {};
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    configRequests[key] = (configRequests[key] || 0) + 1;
                    console.log(`Configuration requested for key: ${key}`);
                    switch (key) {
                        case 'importModulePaths': 
                            return ['ReplicatedStorage.src._Import'];
                        case 'tryToAddImportRequire':
                            return true;
                        case 'importOpacity':
                            return 0.45;
                        default:
                            console.log(`Unknown configuration key requested: ${key}`);
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            try {
                // Use mock editor directly since VSCode test environment doesn't support 'luau' language
                const mockEditor = {
                    document: {
                        languageId: 'luau',
                        getText: () => testContent
                    },
                    setDecorations: () => {}
                };
                
                console.log('Testing hideLines with mock editor');
                console.log('Mock document language:', mockEditor.document.languageId);
                console.log('Mock document text:', mockEditor.document.getText());
                
                hideLines(mockEditor);
                
                console.log('Configuration requests made:', configRequests);
                console.log('Prompt shown:', promptShown);
                console.log('Captured warning message:', capturedWarningMessage);
                
                assert.ok(promptShown, 'Should prompt to add missing import require definition');
            } finally {
                vscode.window.showWarningMessage = originalShowWarningMessage;
                vscode.workspace.getConfiguration = originalConfig;
            }
        });

        test('Should not prompt for empty files', async () => {
            const originalShowWarningMessage = vscode.window.showWarningMessage;
            let promptShown = false;
            vscode.window.showWarningMessage = () => {
                promptShown = true;
                return Promise.resolve('No');
            };

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'tryToAddImportRequire':
                            return true;
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            try {
                // Use mock editor for empty file test
                const mockEditor = {
                    document: {
                        languageId: 'luau',
                        getText: () => ''
                    },
                    setDecorations: () => {}
                };
                
                hideLines(mockEditor);
                
                assert.ok(!promptShown, 'Should not prompt for empty files');
            } finally {
                vscode.window.showWarningMessage = originalShowWarningMessage;
                vscode.workspace.getConfiguration = originalConfig;
            }
        });

        test('Should support multiple import module paths', async () => {
            const testContent = `
require = require(game:GetService("ReplicatedStorage").src._Import)(script) :: typeof(require)
local MyModule = require("@MyModule")
            `.trim();

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'importModulePaths':
                            return [
                                'ReplicatedStorage.src._Import',
                                'game:GetService("ReplicatedStorage").src._Import'
                            ];
                        case 'importOpacity':
                            return 0.3;
                        case 'tryToAddImportRequire':
                            return false;
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            try {
                // Use mock editor
                const mockEditor = {
                    document: {
                        languageId: 'luau',
                        getText: () => testContent
                    },
                    setDecorations: () => {}
                };
                
                // Should not throw an error and should recognize the alternative path
                hideLines(mockEditor);
                assert.ok(true, 'Should handle multiple import module paths');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
            }
        });

        test('Should identify import require definitions', async () => {
            const testContent = `
require = require(ReplicatedStorage.src._Import)(script) :: typeof(require)
-- selene: allow(incorrect_standard_library_use)

local MyModule = require("@MyModule")
return MyModule
            `.trim();

            // Mock configuration with complete interface
            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'importModulePaths':
                            return ['ReplicatedStorage.src._Import'];
                        case 'importOpacity':
                            return 0.3;
                        case 'tryToAddImportRequire':
                            return false;
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            try {
                // Use mock editor
                const mockEditor = {
                    document: {
                        languageId: 'luau',
                        getText: () => testContent
                    },
                    setDecorations: () => {}
                };
                
                hideLines(mockEditor);
                
                // Check that decorations were applied
                // Note: We can't directly test decorations in unit tests, 
                // but we can verify the function doesn't throw
                assert.ok(true, 'hideLines should execute without errors');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
            }
        });

        test('Debug hideLines configuration keys', async () => {
            // This test specifically debugs what configuration keys hideLines is actually requesting
            const testContent = `
local MyModule = require("@MyModule")
return MyModule
            `.trim();

            const originalConfig = vscode.workspace.getConfiguration;
            let configRequests = [];
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    configRequests.push(key);
                    console.log(`hideLines requested config key: "${key}"`);
                    // Return reasonable defaults
                    switch (key) {
                        case 'importModulePaths':
                            return ['ReplicatedStorage.src._Import'];
                        case 'tryToAddImportRequire':
                            return true;
                        case 'importOpacity':
                            return 0.45;
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            try {
                // Use mock editor
                const mockEditor = {
                    document: {
                        languageId: 'luau',
                        getText: () => testContent
                    },
                    setDecorations: () => {}
                };
                
                hideLines(mockEditor);
                console.log('All configuration keys requested by hideLines:', configRequests);
                assert.ok(true, 'Debug test completed');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
            }
        });

        test('Should not prompt when file already has import require definition', async () => {
            const testContent = `
require = require(ReplicatedStorage:FindFirstChild("_Import", true))(script) :: typeof(require)
local MyModule = require("@MyModule")
return MyModule
            `.trim();

            const originalShowWarningMessage = vscode.window.showWarningMessage;
            let promptShown = false;
            vscode.window.showWarningMessage = () => {
                promptShown = true;
                return Promise.resolve('No');
            };

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'importModulePaths':
                            return ['ReplicatedStorage:FindFirstChild("_Import", true)'];
                        case 'tryToAddImportRequire':
                            return true;
                        case 'importOpacity':
                            return 0.45;
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            try {
                const mockEditor = {
                    document: {
                        languageId: 'luau',
                        getText: () => testContent
                    },
                    setDecorations: () => {}
                };
                
                hideLines(mockEditor);
                
                assert.ok(!promptShown, 'Should not prompt when import require definition already exists');
            } finally {
                vscode.window.showWarningMessage = originalShowWarningMessage;
                vscode.workspace.getConfiguration = originalConfig;
            }
        });

        test('Should not prompt when file has no @ require statements', async () => {
            const testContent = `
local MyModule = require("./LocalModule")
local AnotherModule = require("game.ReplicatedStorage.SomeModule")
return MyModule
            `.trim();

            const originalShowWarningMessage = vscode.window.showWarningMessage;
            let promptShown = false;
            vscode.window.showWarningMessage = () => {
                promptShown = true;
                return Promise.resolve('No');
            };

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'importModulePaths':
                            return ['ReplicatedStorage:FindFirstChild("_Import", true)'];
                        case 'tryToAddImportRequire':
                            return true;
                        case 'importOpacity':
                            return 0.45;
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            try {
                const mockEditor = {
                    document: {
                        languageId: 'luau',
                        getText: () => testContent
                    },
                    setDecorations: () => {}
                };
                
                hideLines(mockEditor);
                
                assert.ok(!promptShown, 'Should not prompt when no @ require statements exist');
            } finally {
                vscode.window.showWarningMessage = originalShowWarningMessage;
                vscode.workspace.getConfiguration = originalConfig;
            }
        });

        test('Should not process non-Luau files', async () => {
            const originalConfig = vscode.workspace.getConfiguration;
            let configRequested = false;
            vscode.workspace.getConfiguration = () => {
                configRequested = true;
                return {
                    get: () => undefined,
                    has: () => true,
                    inspect: () => undefined,
                    update: () => Promise.resolve()
                };
            };

            try {
                const mockEditor = {
                    document: {
                        languageId: 'javascript',
                        getText: () => 'console.log("test");'
                    },
                    setDecorations: () => {}
                };
                
                hideLines(mockEditor);
                
                assert.ok(!configRequested, 'Should not process non-Luau files');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
            }
        });
    });

    suite('File Alias Generation Edge Cases', () => {
        test('Should handle files with same basename in different subdirectories', async () => {
            // Create additional test structure
            const testDirs = ['src/Server/Combat', 'src/Client/Combat'];
            for (const dir of testDirs) {
                const fullPath = path.join(testWorkspacePath, dir);
                if (!fs.existsSync(fullPath)) {
                    fs.mkdirSync(fullPath, { recursive: true });
                }
            }

            const conflictFiles = {
                'src/Server/Combat/Weapon.luau': 'local ServerWeapon = {}\nreturn ServerWeapon',
                'src/Client/Combat/Weapon.luau': 'local ClientWeapon = {}\nreturn ClientWeapon'
            };

            for (const [filePath, content] of Object.entries(conflictFiles)) {
                const fullPath = path.join(testWorkspacePath, filePath);
                fs.writeFileSync(fullPath, content, 'utf8');
            }

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'directoriesToScan':
                            return ['src/Server', 'src/Client'];
                        case 'ignoreDirectories':
                            return ['^_.*'];
                        case 'supportedExtensions':
                            return ['.lua', '.luau'];
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                generateFileAliases();
                
                const luaurcPath = path.join(testWorkspacePath, '.luaurc');
                const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
                
                // Weapon should not be aliased due to ambiguity
                assert.ok(!luaurcContent.aliases.Weapon, 'Ambiguous files should not generate aliases');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                // Clean up
                for (const filePath of Object.keys(conflictFiles)) {
                    const fullPath = path.join(testWorkspacePath, filePath);
                    if (fs.existsSync(fullPath)) fs.unlinkSync(fullPath);
                }
            }
        });

        test('Should recognize files and folders with init.luau files that share the same name constitute an ambiguous alias', async () => {
            // Test sequence: standalone file exists → alias created → init file added → alias becomes ambiguous and removed → init file removed → alias restored for standalone file
            
            const testDir = path.join(testWorkspacePath, 'src/Shared/TestModule');
            const standaloneFile = path.join(testWorkspacePath, 'src/Shared/TestModule.luau');
            const initFile = path.join(testDir, 'init.luau');

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'directoriesToScan':
                            return ['src/Shared'];
                        case 'ignoreDirectories':
                            return ['^_.*'];
                        case 'supportedExtensions':
                            return ['.lua', '.luau'];
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                // Step 1: Create standalone file only
                fs.writeFileSync(standaloneFile, 'return { standalone = true }');
                generateFileAliases();
                
                let luaurcPath = path.join(testWorkspacePath, '.luaurc');
                let luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
                
                assert.ok(luaurcContent.aliases.TestModule, 'Step 1: Should create alias when only standalone file exists');
                assert.ok(luaurcContent.aliases.TestModule.includes('TestModule.luau'), 'Step 1: Should point to standalone file');

                // Step 2: Add init file (creates ambiguity)
                fs.mkdirSync(testDir, { recursive: true });
                fs.writeFileSync(initFile, 'return { main = true }');
                generateFileAliases();
                
                luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
                
                assert.ok(!luaurcContent.aliases.TestModule, 'Step 2: Should NOT create alias when both init file and standalone file exist (ambiguous)');
                
                // Check that no TestModule alias was created in auto-generated aliases
                const autoGeneratedKeys = Object.keys(luaurcContent.aliases).filter(key => 
                    !['@Server', '@Client', '@Shared'].includes(key)
                );
                assert.ok(!autoGeneratedKeys.includes('TestModule'), 'Step 2: TestModule should not be in auto-generated aliases due to ambiguity');

                // Step 3: Remove init file (removes ambiguity, standalone file should get alias again)
                fs.rmSync(testDir, { recursive: true, force: true });
                generateFileAliases();
                
                luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
                
                assert.ok(luaurcContent.aliases.TestModule, 'Step 3: Should restore alias when init file removed and only standalone remains');
                assert.ok(luaurcContent.aliases.TestModule.includes('TestModule.luau'), 'Step 3: Should point to standalone file again');

            } finally {
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                // Clean up
                if (fs.existsSync(testDir)) {
                    fs.rmSync(testDir, { recursive: true, force: true });
                }
                if (fs.existsSync(standaloneFile)) {
                    fs.unlinkSync(standaloneFile);
                }
            }
        });
    });

    suite('Configuration Tests', () => {
        test('Should handle missing configuration gracefully', () => {
            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    // Return sensible defaults for critical config
                    switch (key) {
                        case 'directoriesToScan':
                            return [];
                        case 'ignoreDirectories':
                            return [];
                        case 'supportedExtensions':
                            return ['.lua', '.luau'];
                        default:
                            return undefined;
                    }
                },
                has: () => false,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                // Should not throw error with missing configuration
                assert.doesNotThrow(() => {
                    generateFileAliases();
                }, 'Should handle missing configuration gracefully');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
            }
        });

        test('Should handle invalid JSON in config files', () => {
            // Back up original files first
            const luaurcPath = path.join(testWorkspacePath, '.luaurc');
            const extensionConfigPath = path.join(testWorkspacePath, '.requireonrails.json');
            
            let originalLuaurc = '';
            let originalExtensionConfig = '';
            if (fs.existsSync(luaurcPath)) {
                originalLuaurc = fs.readFileSync(luaurcPath, 'utf8');
            }
            if (fs.existsSync(extensionConfigPath)) {
                originalExtensionConfig = fs.readFileSync(extensionConfigPath, 'utf8');
            }
            
            // Create invalid JSON files
            fs.writeFileSync(luaurcPath, '{ invalid json }');
            fs.writeFileSync(extensionConfigPath, '{ also invalid }');

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'directoriesToScan':
                            return ['src/Server'];
                        case 'ignoreDirectories':
                            return [];
                        case 'supportedExtensions':
                            return ['.luau'];
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            const originalShowErrorMessage = vscode.window.showErrorMessage;
            let errorShown = false;
            vscode.window.showErrorMessage = (message) => {
                errorShown = true;
                return Promise.resolve();
            };

            try {
                generateFileAliases();
                
                assert.ok(errorShown, 'Should show error message for invalid JSON');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
                vscode.window.showErrorMessage = originalShowErrorMessage;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                
                // Restore original files
                if (originalLuaurc) {
                    fs.writeFileSync(luaurcPath, originalLuaurc);
                }
                if (originalExtensionConfig) {
                    fs.writeFileSync(extensionConfigPath, originalExtensionConfig);
                }
            }
        });
    });

    suite('Require Statement Update Edge Cases', () => {
        test('Should handle files with no extension change', () => {
            const { analyzeFileOperation } = require('../src/updateRequireNames');
            
            // Test when only directory changes, no filename change
            const oldPath = path.join(testWorkspacePath, 'src/Server/Utils.luau');
            const newPath = path.join(testWorkspacePath, 'src/Shared/Utils.luau');
            
            const operationInfo = analyzeFileOperation(newPath, oldPath);
            
            assert.ok(operationInfo !== null, 'Should detect operation');
            assert.strictEqual(operationInfo.operationType, 'moved', 'Should be move operation');
            assert.strictEqual(operationInfo.oldFileBasename, 'Utils', 'Should extract correct old basename');
            assert.strictEqual(operationInfo.newFileBasename, 'Utils', 'Should extract correct new basename');
        });

        test('Should handle files with both directory and name change', () => {
            const { analyzeFileOperation } = require('../src/updateRequireNames');
            
            const oldPath = path.join(testWorkspacePath, 'src/Server/OldUtils.luau');
            const newPath = path.join(testWorkspacePath, 'src/Shared/NewUtils.luau');
            
            const operationInfo = analyzeFileOperation(newPath, oldPath);
            
            assert.ok(operationInfo !== null, 'Should detect operation');
            assert.strictEqual(operationInfo.operationType, 'moved and renamed', 'Should be move and rename operation');
            assert.strictEqual(operationInfo.isMove, true, 'Should detect directory change');
            assert.strictEqual(operationInfo.isRename, true, 'Should detect filename change');
        });

        test('Should return null for identical paths', () => {
            const { analyzeFileOperation } = require('../src/updateRequireNames');
            
            const samePath = path.join(testWorkspacePath, 'src/Server/Utils.luau');
            const operationInfo = analyzeFileOperation(samePath, samePath);
            
            assert.strictEqual(operationInfo, null, 'Should return null for identical paths');
        });
    });

    suite('Edge Case File Operations', () => {
        test('Should handle files with special characters', () => {
            const specialFiles = {
                'src/Server/File-With-Dashes.luau': 'return {}',
                'src/Server/File_With_Underscores.luau': 'return {}',
                'src/Server/FileWithNumbers123.luau': 'return {}'
            };

            // Create special files
            for (const [filePath, content] of Object.entries(specialFiles)) {
                const fullPath = path.join(testWorkspacePath, filePath);
                fs.writeFileSync(fullPath, content, 'utf8');
            }

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'directoriesToScan':
                            return ['src/Server'];
                        case 'ignoreDirectories':
                            return [];
                        case 'supportedExtensions':
                            return ['.luau'];
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                generateFileAliases();
                
                const luaurcPath = path.join(testWorkspacePath, '.luaurc');
                const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
                
                // Should handle special characters in filenames
                assert.ok(luaurcContent.aliases['File-With-Dashes'], 'Should handle dashes in filenames');
                assert.ok(luaurcContent.aliases['File_With_Underscores'], 'Should handle underscores in filenames');
                assert.ok(luaurcContent.aliases['FileWithNumbers123'], 'Should handle numbers in filenames');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                // Clean up
                for (const filePath of Object.keys(specialFiles)) {
                    const fullPath = path.join(testWorkspacePath, filePath);
                    if (fs.existsSync(fullPath)) fs.unlinkSync(fullPath);
                }
            }
        });

        test('Should ignore .server and .client files', () => {
            const serverClientFiles = {
                'src/Server/ServerScript.server.luau': 'print("server")',
                'src/Client/ClientScript.client.luau': 'print("client")',
                'src/Shared/RegularScript.luau': 'print("regular")'
            };

            // Create server/client files
            for (const [filePath, content] of Object.entries(serverClientFiles)) {
                const fullPath = path.join(testWorkspacePath, filePath);
                fs.writeFileSync(fullPath, content, 'utf8');
            }

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'directoriesToScan':
                            return ['src/Server', 'src/Client', 'src/Shared'];
                        case 'ignoreDirectories':
                            return [];
                        case 'supportedExtensions':
                            return ['.luau'];
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                generateFileAliases();
                
                const luaurcPath = path.join(testWorkspacePath, '.luaurc');
                const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
                
                // Should ignore server/client files but include regular files
                assert.ok(!luaurcContent.aliases.ServerScript, 'Should ignore .server files');
                assert.ok(!luaurcContent.aliases.ClientScript, 'Should ignore .client files');
                assert.ok(luaurcContent.aliases.RegularScript, 'Should include regular files');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                // Clean up
                for (const filePath of Object.keys(serverClientFiles)) {
                    const fullPath = path.join(testWorkspacePath, filePath);
                    if (fs.existsSync(fullPath)) fs.unlinkSync(fullPath);
                }
            }
        });
    });
	
	suite('Regex Pattern Tests', () => {
        test('Should ignore directories matching regex patterns', () => {
            const testDirs = ['_Private', '_Test', 'Normal', '__pycache__', 'node_modules'];
            const ignorePatterns = ['^_.*', '__pycache__', 'node_modules'];
            
            function shouldIgnoreDirectory(dirName, ignorePatterns) {
                return ignorePatterns.some(pattern => {
                    try {
                        return new RegExp(pattern).test(dirName);
                    } catch (e) {
                        return dirName.toLowerCase() === pattern.toLowerCase();
                    }
                });
            }

            assert.ok(shouldIgnoreDirectory('_Private', ignorePatterns), 'Should ignore _Private');
            assert.ok(shouldIgnoreDirectory('_Test', ignorePatterns), 'Should ignore _Test');
            assert.ok(!shouldIgnoreDirectory('Normal', ignorePatterns), 'Should not ignore Normal');
            assert.ok(shouldIgnoreDirectory('__pycache__', ignorePatterns), 'Should ignore __pycache__');
            assert.ok(shouldIgnoreDirectory('node_modules', ignorePatterns), 'Should ignore node_modules');
        });

        test('Should handle invalid regex patterns gracefully', () => {
            const invalidPattern = '[invalid';
            
            function shouldIgnoreDirectory(dirName, ignorePatterns) {
                return ignorePatterns.some(pattern => {
                    try {
                        return new RegExp(pattern).test(dirName);
                    } catch (e) {
                        // Fall back to exact string matching
                        return dirName.toLowerCase() === pattern.toLowerCase();
                    }
                });
            }

            // Should not throw and should fall back to string matching
            assert.ok(!shouldIgnoreDirectory('test', [invalidPattern]), 'Should handle invalid regex');
            assert.ok(shouldIgnoreDirectory('[invalid', [invalidPattern]), 'Should fall back to string matching');
        });
    });

    suite('Project Template Tests', () => {
        test('Should handle missing ProjectTemplate directory gracefully', () => {
            const { unpackProjectTemplate } = require('../src/unpackProjectTemplate');
            
            const originalShowErrorMessage = vscode.window.showErrorMessage;
            let errorShown = false;
            let capturedErrorMessage = '';
            vscode.window.showErrorMessage = (message) => {
                errorShown = true;
                capturedErrorMessage = message;
                return Promise.resolve();
            };

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                unpackProjectTemplate();
                
                assert.ok(errorShown, 'Should show error when ProjectTemplate directory is missing');
                assert.ok(capturedErrorMessage.includes('Project template not found'), 'Should indicate template not found');
            } finally {
                vscode.window.showErrorMessage = originalShowErrorMessage;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
            }
        });

        test('Should handle missing workspace folder', () => {
            const { unpackProjectTemplate } = require('../src/unpackProjectTemplate');
            
            const originalShowErrorMessage = vscode.window.showErrorMessage;
            let errorShown = false;
            let capturedErrorMessage = '';
            vscode.window.showErrorMessage = (message) => {
                errorShown = true;
                capturedErrorMessage = message;
                return Promise.resolve();
            };

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: null,
                writable: true,
                configurable: true
            });

            try {
                unpackProjectTemplate();
                
                assert.ok(errorShown, 'Should show error when no workspace folder found');
                assert.ok(capturedErrorMessage.includes('No workspace folder found'), 'Should indicate no workspace found');
            } finally {
                vscode.window.showErrorMessage = originalShowErrorMessage;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
            }
        });

        test('Should prompt user when template items already exist', () => {
            const { unpackProjectTemplate } = require('../src/unpackProjectTemplate');
            
            // Create a mock ProjectTemplate directory in the correct location
            // The function expects ProjectTemplate to be a sibling to the extension directory
            const extensionRoot = path.dirname(__dirname); // Go up from test/ to extension root
            const mockTemplatePath = path.join(path.dirname(extensionRoot), 'ProjectTemplate');
            fs.mkdirSync(mockTemplatePath, { recursive: true });
            fs.writeFileSync(path.join(mockTemplatePath, 'src'), 'dummy'); // Create a dummy file named 'src' to simulate directory

            // Create existing item in workspace that matches template
            const existingSrcDir = path.join(testWorkspacePath, 'src');
            if (!fs.existsSync(existingSrcDir)) {
                fs.mkdirSync(existingSrcDir, { recursive: true });
            }

            const originalShowWarningMessage = vscode.window.showWarningMessage;
            let warningShown = false;
            let capturedWarningMessage = '';
            vscode.window.showWarningMessage = (message, ...options) => {
                warningShown = true;
                capturedWarningMessage = message;
                return Promise.resolve('Cancel');
            };

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                unpackProjectTemplate();
                
                assert.ok(warningShown, 'Should show warning when template items already exist');
                assert.ok(capturedWarningMessage.includes('already exist'), 'Should indicate items already exist');
            } finally {
                vscode.window.showWarningMessage = originalShowWarningMessage;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                // Clean up mock template
                if (fs.existsSync(mockTemplatePath)) {
                    fs.rmSync(mockTemplatePath, { recursive: true, force: true });
                }
            }
        });

        test('Should handle file copy operations correctly', () => {
            const { unpackProjectTemplate } = require('../src/unpackProjectTemplate');
            
            // Create a mock ProjectTemplate directory with test files in the correct location
            const extensionRoot = path.dirname(__dirname); // Go up from test/ to extension root
            const mockTemplatePath = path.join(path.dirname(extensionRoot), 'ProjectTemplate');
            fs.mkdirSync(mockTemplatePath, { recursive: true });
            fs.mkdirSync(path.join(mockTemplatePath, 'testDir'), { recursive: true });
            fs.writeFileSync(path.join(mockTemplatePath, 'test.txt'), 'test content');
            fs.writeFileSync(path.join(mockTemplatePath, 'testDir', 'init.luau'), 'print("test")');

            const originalShowInformationMessage = vscode.window.showInformationMessage;
            const originalShowWarningMessage = vscode.window.showWarningMessage;
            const originalShowErrorMessage = vscode.window.showErrorMessage;
            
            let successShown = false;
            let capturedSuccessMessage = '';
            let errorShown = false;
            let capturedErrorMessage = '';
            let warningShown = false;
            
            vscode.window.showInformationMessage = (message, ...options) => {
                console.log('Info message:', message);
                successShown = true;
                capturedSuccessMessage = message;
                return Promise.resolve();
            };
            
            vscode.window.showWarningMessage = (message, ...options) => {
                console.log('Warning message:', message);
                warningShown = true;
                return Promise.resolve('Yes'); // Continue with the operation
            };
            
            vscode.window.showErrorMessage = (message) => {
                console.log('Error message:', message);
                errorShown = true;
                capturedErrorMessage = message;
                return Promise.resolve();
            };

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                console.log('Template path exists:', fs.existsSync(mockTemplatePath));
                console.log('Template contents:', fs.readdirSync(mockTemplatePath));
                console.log('Workspace path:', testWorkspacePath);
                
                unpackProjectTemplate();
                
                if (errorShown) {
                    console.log('Error occurred:', capturedErrorMessage);
                    assert.fail(`Error occurred during template unpacking: ${capturedErrorMessage}`);
                }
                
                assert.ok(successShown, `Should show success message after copying. Success: ${successShown}, Message: "${capturedSuccessMessage}"`);
                assert.ok(capturedSuccessMessage.includes('successfully'), 'Should indicate successful completion');
                
                // Verify files were copied
                assert.ok(fs.existsSync(path.join(testWorkspacePath, 'test.txt')), 'Should copy files from template');
                assert.ok(fs.existsSync(path.join(testWorkspacePath, 'testDir', 'init.luau')), 'Should copy nested files from template');
                
                // Verify file content
                const copiedContent = fs.readFileSync(path.join(testWorkspacePath, 'test.txt'), 'utf8');
                assert.strictEqual(copiedContent, 'test content', 'Should preserve file content during copy');
            } finally {
                vscode.window.showInformationMessage = originalShowInformationMessage;
                vscode.window.showWarningMessage = originalShowWarningMessage;
                vscode.window.showErrorMessage = originalShowErrorMessage;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                // Clean up
                if (fs.existsSync(mockTemplatePath)) {
                    fs.rmSync(mockTemplatePath, { recursive: true, force: true });
                }
                // Clean up copied files
                const copiedFiles = [
                    path.join(testWorkspacePath, 'test.txt'),
                    path.join(testWorkspacePath, 'testDir', 'init.luau')
                ];
                for (const file of copiedFiles) {
                    if (fs.existsSync(file)) {
                        fs.unlinkSync(file);
                    }
                }
            }
        });
    });

    suite('Extension Activation Tests', () => {
        test('Should register setupDefaultProject command', () => {
            // Test that the command is properly registered
            // In a real test environment, you would check:
            // - Command is registered in extension activation
            // - Command can be executed via command palette
            // - Command properly calls unpackProjectTemplate function
            assert.ok(true, 'setupDefaultProject command registration test placeholder');
        });

        test('Should auto-generate file aliases for new files', async () => {
            const newFile = path.join(testWorkspacePath, 'src/Server/NewFile.luau');
            fs.writeFileSync(newFile, 'return {}');

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'directoriesToScan':
                            return ['src/Server'];
                        case 'ignoreDirectories':
                            return [];
                        case 'supportedExtensions':
                            return ['.lua', '.luau'];
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                // Simulate file creation
                fs.writeFileSync(newFile, 'return {}');
                
                // Manually trigger alias generation (in real scenario, this would be automatic)
                generateFileAliases();
                
                const luaurcPath = path.join(testWorkspacePath, '.luaurc');
                const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
                
                assert.ok(luaurcContent.aliases.NewFile, 'New file should have an alias');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                if (fs.existsSync(newFile)) fs.unlinkSync(newFile);
            }
        });

        test('Should not overwrite existing aliases on file update', async () => {
            const existingFile = path.join(testWorkspacePath, 'src/Server/ExistingFile.luau');
            fs.writeFileSync(existingFile, 'return {}');

            const originalConfig = vscode.workspace.getConfiguration;
            vscode.workspace.getConfiguration = () => ({
                get: (key) => {
                    switch (key) {
                        case 'directoriesToScan':
                            return ['src/Server'];
                        case 'ignoreDirectories':
                            return [];
                        case 'supportedExtensions':
                            return ['.lua', '.luau'];
                        default:
                            return undefined;
                    }
                },
                has: () => true,
                inspect: () => undefined,
                update: () => Promise.resolve()
            });

            const originalWorkspaceFolders = vscode.workspace.workspaceFolders;
            Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                value: [{ uri: testWorkspaceUri }],
                writable: true,
                configurable: true
            });

            try {
                // Simulate file update
                fs.writeFileSync(existingFile, '-- updated content');
                
                // Manually trigger alias generation
                generateFileAliases();
                
                const luaurcPath = path.join(testWorkspacePath, '.luaurc');
                const luaurcContent = JSON.parse(fs.readFileSync(luaurcPath, 'utf8'));
                
                // Alias should already exist, so it should not be overwritten
                assert.ok(luaurcContent.aliases.ExistingFile, 'Existing file should have an alias');
                assert.ok(luaurcContent.aliases.ExistingFile.includes('ExistingFile.luau'), 'Alias should point to the correct file');
            } finally {
                vscode.workspace.getConfiguration = originalConfig;
                Object.defineProperty(vscode.workspace, 'workspaceFolders', {
                    value: originalWorkspaceFolders,
                    writable: true,
                    configurable: true
                });
                if (fs.existsSync(existingFile)) fs.unlinkSync(existingFile);
            }
        });
    });
})